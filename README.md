# py_big_homework

## 项目介绍

本项目用于存储罗老师上课期间所布置的小组大作业

### 项目 1：Hog 游戏

#### 1. 介绍

在这个项目中，需要为 Hog（骰子游戏）开发模拟器和多种策略，实现过程需要结合使用控制和高阶函数。在 Hog 游戏中，`两名玩家轮流尝试投掷骰子先达到100分的胜出`。在每一轮中，当前玩家选择一定数量的骰子来掷骰子，最多 10 个，一个回合得分是该回合所有投掷骰子结果的总和或者为 1。

为了给游戏增添趣味，我们将玩一些特殊的规则：

- Pig out： 如果玩家一轮投掷骰子过程中出现了一次 1，则该回合该玩家得分为 1

- Free bacon： 如果玩家选择掷零个骰子，则其得分比对手得分中各位上最大的数字多 1。例如，如果玩家 1 有 42 分，则玩家 0 通过掷零骰子获得 1 + max(4, 2) = 5 分。如果玩家 1 有 48 分，则玩家 0 获得 1 + max(4, 8) = 9 分。

- Hog wild： 如果两位玩家的总分之和是七的倍数（例如，14、21、35），则当前玩家掷四面骰子而不是通常的六面骰子。

- Swine swap：如果在回合结束时其中一位玩家的总分恰好是另一位玩家总分的两倍，则玩家交换总分。 例 1：选手 0 有 20 分，选手 1 有 5 分；轮到玩家 1 了。她又得了 5 分，总分达到 10 分。玩家交换分数：玩家 0 现在有 10 分，玩家 1 有 20 分。现在轮到玩家 0 了。 示例 2：玩家 0 有 90 分，玩家 1 有 50；轮到玩家 0 了。她又得了 10 分，使她的总分达到 100。玩家交换得分，玩家 1 以 100 比 50 赢得比赛。

该项目包括六个文件，但所有更改都将对第一个文件进行，并且这是唯一需要阅读和理解的文件。下载所有项目代码并解压项目得到下列文件：

```tex
hog.py ：Hog 的初始实现。

dice.py ：掷骰子的函数。

ucb.py ：CS 61A 的实用功能。

hog_gui.py：Hog 的图形用户界面。

hog_grader.py：测试以检查您的实施的正确性。

autograder.py：用于分级的实用函数。
```

小组将提交整个项目，仅需要提交的唯一文件是 hog.py。该项目价值 20 分，正确性得 14 分，程序的整体可维可读等得 6 分。

对于我们要求完成的功能，可能会提供一些初始代码。如果不想使用该代码，请随时将其删除并从头开始。还可以根据需要添加新的函数定义。但是，请不要修改任何其他功能。这样做可能会导致您的代码无法通过我们的 autograder 测试。此外，不要更改任何函数签名（名称、参数顺序或参数数量）。

##### 图形用户界面

提供的图形用户界面（简称 GUI）。目前它不起作用，因为还没有实现游戏逻辑。完成问题 4（play 函数）后，您就可以玩完全互动版的 Hog！为了渲染图形，请确保您的计算机上安装了 Python 的主要图形库 Tkinter。完成后，您可以从终端运行 GUI：

```python
python pythonhog_gui.py
```

##### 测试

在整个项目中，您应该测试代码的正确性。经常测试是个好习惯，这样很容易隔离任何问题。

许多测试都包含在 hog.py. 附加测试在 hog_grader.py. 要运行所有测试直到发现问题，请运行

```python
python hog_grader.py
```

上面的命令运行所有测试，直到发生错误，此时它将停止并打印一些错误消息。您还可以针对特定问题运行测试-q：

```python
 pythonhog_grader.py -q 1
```

在 中 hog.py，我们还提供了一种从终端交互调用某些函数的方法：

```python
python hog.py -i roll_dice
```

#### 2.第一阶段：模拟器

在第一阶段，将为 Hog 游戏开发一个模拟器。

##### 问题 1（2 分）

实现 roll_dice 中的函数 hog.py，该函数返回多次投掷骰子的总点数或 1。

每次掷骰子的单个结果，通过调用 dice()获得。投掷 num_rolls 次则调用 dice()函数 num_rolls 次。实现中需要考虑 Pig out 规则的实现。

在开发过程可以添加 print 语句以查看程序中发生了什么。完成后移除它们。

测试实现代码：

```python
python hog_grader.py -q 1
```

还可以运行交互式测试：

```python
  pythonhog.py -i roll_dice
```

##### 问题 2 （1 分)

实现 take_turn 函数，并返回该回合的得分。需要在此处实现 Free bacon 规则，实现需要调用 roll_dice.

测试实现代码：

```python
python hog_grader.py -q 2
```

还可以交互式运行 take_turn。

```python
python hog.py -i take_turn
```

##### 问题 3 (1 分)

实现一个辅助函数 select_dice，将简化（下一个问题）play 的实现。该函数 select_dice 有助于执行 Hog wild。此函数有两个参数：当前和对方玩家的得分。

测试实现代码：

```python
python hog_grader.py -q 3
```

##### 问题 4（3 分)

实现 play 模拟一整场 Hog 游戏的功能。玩家轮流轮流使用最初提供的策略，直到其中一名玩家达到 goal 分数（缺省为 100）。当游戏结束时，play 返回两个玩家的最终总分，首先是玩家 0 的分数，然后是玩家 1 的分数。

这里有一些提示：

请记住执行所有特殊规则！您应该在这里执行 Hog wild 特殊规则（通过使用 select_dice），以及 Swine swap 特殊规则。

需要调用 take_turn 函数。

可以通过调用提供的函数来获取其他玩家的值（0 或 1）other。例如，other(0)为 1。

策略是一种函数，它根据两个玩家的得分来确定玩家想要掷多少次骰子。策略函数（例如 strategy0 和 strategy1）有两个参数：当前玩家和对方玩家的分数。一个策略函数返回当前玩家想要在回合中掷的骰子数。不要担心实施策略的细节，将在第 2 阶段开发它们。

测试实现代码：

```python
python hog_grader.py -q 4
```

交互式测试，在这里您可以选择为两个玩家掷多少骰子。你会想要添加 print 语句来显示玩游戏的结果，但一定要在进入第 2 阶段之前删除它们。

```python
python hog.py -i play
```

测试通过后将能够玩游戏的图形版本。我们提供了一个名为的文件 hog_gui.py，您可以从终端运行该文件：

```python
python hog_gui.py
```

如果您还没有安装 Tkinter（Python 的图形库），则需要先安装它，然后才能运行 GUI。

GUI 依赖于您的实现，因此如果您的代码中有任何错误，它们将反映在 GUI 中。这意味着您还可以将 GUI 用作调试工具；但是，最好先运行测试。

恭喜！你已经完成了这个项目的第一阶段！

#### 3. 第二阶段：策略

在第二阶段，您将尝试改进始终掷固定数量骰子的基本策略的方法。首先，您需要开发一些工具来评估策略。

##### 问题 5（2 分)

实现 make_averaged 功能。这个高阶函数以一个函数 fn 作为参数。它返回另一个函数，该函数采用与原始函数相同数量的参数。fn 此返回函数与输入函数的不同之处在于，它返回重复调用相同参数的平均值。此函数功能为调用 fn 总次数 num_samples 次并返回结果的平均值。

注意：如果输入函数 fn 是非纯函数（例如函数 random），那么 make_averaged 也将是非纯函数。要实现这个功能，你需要一段新的 Python 语法！您必须编写一个接受任意数量参数的函数，然后使用这些参数调用另一个函数。这是它的工作原理。

我们不列出函数的形式参数，而是编写 *args. 要使用这些参数调用另一个函数，我们再次调用它*args。例如，

仔细阅读文档字符串 make_averaged 以了解它的工作原理。

测试实现代码：

```python
python hog_grader.py -q 5
```

##### 问题 6（2 分）

实现 max_scoring_num_rolls 函数，它运行一个实验来确定给出一个回合的最大平均得分的掷骰数（从 1 到 10）。需要使用 make_averaged 和 roll_dice。它需要打印出所有可能掷骰数的平均值，就像在 doctest 中一样 max_scoring_num_rolls。

测试实现代码：

```python
python hog_grader.py -q 6
```

要在随机骰子上运行此实验，

请 run_experiments 使用以下-r 选项调用：

```python
python hog.py -r
```

运行实验

run_experiments 对于本项目的其余部分，您可以根据需要更改 的实现。通过调用 average_win_rate，您可以评估各种 Hog 策略。例如，将第一个更改 if False:为 if True:，以便 always_roll(8)根据 的基线策略进行评估 always_roll(5)。您应该会发现它输的次数多于赢的次数，因此胜率低于 0.5。

某些实验可能需要长达一分钟的时间才能运行。您始终可以减少样本数量以 make_averaged 加快实验速度。

##### 问题 7（1 分）

策略可以通过在最有利的时候选择投掷 0 次骰子(利用 Free bacon), 实现 bacon_strategy，如果投掷 0 次得分不小于 BACON_MARGIN 则返回 0，否则返回 BASELINE_NUM_ROLLS（这两个全局变量位于 always_roll 函数的正上方）。

测试实现代码：

```python
python hog_grader.py -q 7
```

##### 问题 8（2 分）

策略也可以利用 Swine swap。实施 swap_strategy，其中

如果投掷 0 次有益的 Swine swap， 则投掷 0 次。

如果投掷 0 会导致有害交换并失去分数，则掷 BASELINE_NUM_ROLLS 次。

如果投掷 0 次不会导致交换，那么它至少能获得 BACON_MARGIN 点数，否则投掷 BASELINE_NUM_ROLLS 次 。

测试实现代码：

```python
python hog_grader.py -q 8
```

整体运行测试。

```python
python hog_grader.py
```

到这里第一个项目就结束了
